1 Опис прийнятих інженерних рішень

IOT частина проекту розроблена на основі мікроконтролера Espressif ESP32, що базується на архітектурі Xtensa LX6.
Продається як в двоядерних варіаціях, так і одноядерних. Перевагами даного мікроконтролеру являється наявність вбудованого WI-FI та Bluetooth (low-energy) з великою кількістю пінів (32 піни) для підключення зовнішніх пристроїв.
Для симуляції роботи даного мікроконтролера використано платформу Wokwi та PlatformIO IDE розширення для VS Code, що надає можливості гнучкого управління бібліотеками, які використовуються на проекті та надає можливості компіляції коду.
Мовою програмування обрано C++, оскільки саме на цій мові написана найбільша кількість бібліотек під платформу ESP32.
Серед зовнішніх пристроїв використано клавіатуру Keypad 3*4 для вводу цифр вводу 0 до 9 та з наявністю кнопок «*» та «#», які використовуються для підтвердження вводу та скиду набраних цифр до значення по замовченню.
Також використано серво привід для імітації відкриття та закриття замку дверей,
Також для індикації відкриття дверей та індикації режиму адміністратора додано світлодіоди: червоний та зелений.

2 Пояснення програмного коду

2.3.1 Аутентифікація

В проекті аутентифікацію реалізовано за допомогою API-ключа, який передається в заголовку запиту з назвою «x-api-key». Встановлення ключа можна побачити в наступному фрагменті коду:
1server.on("/set-api-key", HTTP_POST, [](AsyncWebServerRequest* request) {
2    if (isAdmin) {
3      apiKey = request->getParam("api-key")->value();
4      request->send(200, "text/plain", "true");
5    } else {
6      request->send(403, "text/plain", "Forbidden");
7    }
8  });
Апі ключ перевіряється при встановленні в початкове значення коду доступу для замка, так наприклад, як от в методі встановлення коду:
1server.on("/set-doorlock-code", HTTP_POST, [](AsyncWebServerRequest* request) {
2  String apiKeyHeader = request->header("x-api-key");
3  if (apiKeyHeader == apiKey) {
4    String newCode = request->getParam("code")->value();
5    roomAccessCode = newCode;
6    request->send(200, "text/plain", "true");
7  }
8  else {
9    request->send(401, "text/plain", "Unauthorized");
10  }
11});


Для встановлення значення ключа передбачено режим адміністратора, який включається за допомогою введення коду або прикладання карти адміністратора. Далі для встановлення значення ключа необхідно відправити запит на адресу «set-api-key» з параметром запиту «api-key» із бажаним значення ключа для подальшої роботи. Після слід вимкнути режим адміністратора натиснувши кнопку «*» і далі можна продовжити користуватись замком.

2.3.2 Робота з сервомотором та світлодіодом

Робота з сервомотором потрібна для емуляції роботи замку дверей. Робота з сервомотором відбувається в методах блокування та розблокування замку дверцят. Для конфігурації необхідно вказати номер піну по якому будуть надсилатись команди та в методі setup виконати команду attach, для якої в якості аргумента функції передати змінну піна сервомотору. Переглянути код конфігурування даних компонентів можна в додатку В.

2.3.2 Робота з клавіатурою для введення цифр (Keypad)

Клавіатура з 10 цифрами та кнопками (далі кейпад) «*» та «#» є основним інтерфейсом взаємодії і потрібна для емуляції роботи замку дверей. Конфігурація відбувається наступним чином: 
1const uint8_t ROWS = 4;
2const uint8_t COLS = 3;
3char keys[ROWS][COLS] = {
4  { '1', '2', '3' },
5  { '4', '5', '6' },
6  { '7', '8', '9' },
7  { '*', '0', '#' }
8};
9
10uint8_t colPins[COLS] = { 21, 22, 23 }; // Pins connected to C1, C2, C3
11uint8_t rowPins[ROWS] = { 19, 18, 17, 4 }; // Pins connected to R1, R2, R3, R4
12
13Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
Далі в методі loop() будемо викликати метод processKeypadSequence(), в якому будемо зчитувати натискання на клавіатуру, та виконувати операції по порівнянню коду доступу, переходу в режим адміністратора та скидання набраної послідовності до по замовчуванню: 
1void processKeypadSequence(bool* isAdmin)
2{
3  char key = keypad.getKey();
4
5  if (key == NO_KEY) {
6    return;
7  }
8
9  if (key == '#')
10  {
11    Serial.println("Checking password");
12
13    if (checkPassword(keyPadSequence, adminPassword))
14    {
15      *isAdmin = true;
16      Serial.println("Admin mode activated");
17    }
18    else if (checkPassword(keyPadSequence, _roomAccessCode))
19    {
20      unlockDoor();
21    }
22    else
23    {
24      lockDoor();
25    }
26
27    keyPadSequence = new String("");
28  }
29  else if (key == '*')
30  {
31    if (*isAdmin)
32    {
33      *isAdmin = false;
34      Serial.println("Admin mode deactivated");
35    }
36    lockDoor();
37    keyPadSequence = new String("");
38  }
39  else
40  {
41    *keyPadSequence += key;
42  }
43
44}


3 UML Діаграми системи
3.1 Діаграма активності IOT пристрою
Першою пропоную розглянути діаграму активності IOT пристрою для програмної система для керування готелем (додаток А).

3.2 Діаграма взаємодії системи
Наступною діаграмою є діаграма взаємодії системи (додаток Б). На ній продемонстровані основні сценарії взаємодії компонентів системи.

3.3 Use-Case діаграма
Наступним кроком будо складено Use-Case діаграму (рис. 2) для відображення можливих сценаріїв дій для користувачів системи.
Передбачено, що система має 3 користувачів: менеджера системи, гостя та адміністратора. Також варто зазначити, що в середині системи у різних користувачів крім адміністратора може бути різний доступ до різних функцій.

3.4 Діаграма станів
Далі пропоную ознайомитись з діаграмою станів (State Diagram), яка різноманітні стани IOT системи (рис. 3) та перехід з одного стану в інший.

4 Висновки 

Під час виконання лабораторної роботи я набув навичок із розробки IOT пристрою та його програми для програмної система для керування роботою готелю
